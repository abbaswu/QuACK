import ast

from collections.abc import Generator

from generate_ast_arg import generate_ast_arg
from query_result_dict import *
from type_inference_result import iterate_type_inference_classes


def generate_ast_function_def_and_function_level_result_dict(
    ast_module: ast.Module,
    module_level_result_dict: ModuleLevelResultDict
) -> Generator[
    tuple[ast.FunctionDef | ast.AsyncFunctionDef, FunctionLevelResultDict],
    None,
    None
]:
    for child in ast_module.body:
        if isinstance(child, (ast.FunctionDef, ast.AsyncFunctionDef)):
            class_name: str = 'global'
            if class_name in module_level_result_dict:
                class_level_result_dict: ClassLevelResultDict = module_level_result_dict[class_name]
                function_name: str = child.name
                if function_name in class_level_result_dict:
                    function_level_result_dict: FunctionLevelResultDict = class_level_result_dict[function_name]
                    yield child, function_level_result_dict
        
        elif isinstance(child, ast.ClassDef):
            class_name: str = child.name
            if class_name in module_level_result_dict:
                class_level_result_dict: ClassLevelResultDict = module_level_result_dict[class_name]
                for grandchild in child.body:
                    if isinstance(grandchild, (ast.FunctionDef, ast.AsyncFunctionDef)):
                        function_name: str = grandchild.name
                        if function_name in class_level_result_dict:
                            function_level_result_dict: FunctionLevelResultDict = class_level_result_dict[function_name]
                            yield grandchild, function_level_result_dict


class ModuleLevelTypeWeaver(ast.NodeTransformer):
    """This ast.NodeTransformer does the following:
    - Adds `import typing` to the top of the file.
    - Add the block `if typing.TYPE_CHECKING: import ...` to the file after `import
typing`. `...` represents each module of the classes within type annotations.
    - Add type annotations as STRINGS.

    Such a design allows us to [add circular imports for type annotations without causing `ImportError`'s](https://adamj.eu/tech/2021/05/13/python-type-hints-how-to-fix-circular-imports/).

    Adapted from code generated by GPT-4 given the following prompts:

    - 'Write a Python ast.NodeTransformer that does the following: 1. Adds `import typing` to the top of the file. 2. Add the block `if typing.TYPE_CHECKING: import ...` to the file after `import
typing`.'
    - 'Write a Python ast.NodeTransformer that adds the type annotation `int` in the form of a string to the parameter `x` of method `m` of class `C`, and the type annotation `str` for the return value of method `m` of class `C`.'
typing`.'
    """
    def __init__(self, module_level_result_dict: ModuleLevelResultDict):
        self.module_level_result_dict = module_level_result_dict

        self.module_name_set: set[str] = set()

        for class_name_or_global, class_level_result_dict in module_level_result_dict.items():
            for function_name, function_level_result_dict in class_level_result_dict.items():
                for parameter_name_or_return, type_annotation_list in function_level_result_dict.items():
                    for type_annotation in type_annotation_list:
                        for type_inference_class in iterate_type_inference_classes(
                            type_annotation
                        ):
                            module_name: str | None = type_inference_class.module_name
                            if module_name is not None:
                                self.module_name_set.add(module_name)

    def visit_Module(self, node: ast.Module) -> ast.Module:
        # Add type annotations in the form of strings for global functions and methods
        for ast_function_def, function_level_result_dict in generate_ast_function_def_and_function_level_result_dict(
            node,
            self.module_level_result_dict
        ):
            # parameters
            for ast_arg in generate_ast_arg(ast_function_def):
                parameter_name = ast_arg.arg
                if parameter_name in function_level_result_dict:
                    type_annotation_list = function_level_result_dict[parameter_name]
                    if type_annotation_list:
                        top_type_annotation = type_annotation_list[0]
                        ast_arg.annotation = ast.Constant(str(top_type_annotation))

            # return value
            if 'return' in function_level_result_dict:
                type_annotation_list = function_level_result_dict['return']
                if type_annotation_list:
                    top_type_annotation = type_annotation_list[0]
                    ast_function_def.returns = ast.Constant(str(top_type_annotation))

        if self.module_name_set:
            # Add "import typing" to the top of the file
            import_typing: ast.Import = ast.Import(names=[ast.alias(name='typing', asname=None)])
            node.body.insert(0, import_typing)

            # Add "if typing.TYPE_CHECKING: import ..." after that
            type_checking_import: ast.If = ast.If(
                test=ast.Attribute(
                    value=ast.Name(id='typing', ctx=ast.Load()),
                    attr='TYPE_CHECKING',
                    ctx=ast.Load()
                ),
                body=[
                    ast.Import(names=[ast.alias(name=module_name, asname=None)])
                    for module_name in self.module_name_set
                ],
                orelse=[]
            )

            node.body.insert(1, type_checking_import)

        # Make sure to fix locations in the AST
        return ast.fix_missing_locations(node)


def weave_types_for_project(
    module_name_to_file_path_dict: dict[str, str],
    result_dict: ResultDict
):
    for module_name, file_path in module_name_to_file_path_dict.items():
        if module_name in result_dict:
            module_level_result_dict: ModuleLevelResultDict = result_dict[module_name]

            input_fp = open(file_path, 'r')
            code: str = input_fp.read()
            input_fp.close()

            tree = ast.parse(code)
            transformer = ModuleLevelTypeWeaver(module_level_result_dict)
            new_tree = transformer.visit(tree)
            new_code = ast.unparse(new_tree)

            output_fp = open(file_path, 'w')
            output_fp.write(new_code)
            output_fp.close()
